#include <stdlib.h>

#include "helper.h"
#include "voucher.h"

mach_voucher_attr_recipe_t create_voucher_recipe(size_t content_size, uint64_t id) {
    mach_voucher_attr_recipe_t user_data_recipe;
    size_t user_data_recipe_size;    
    
    user_data_recipe_size = sizeof(mach_voucher_attr_recipe_data_t) + content_size;
    user_data_recipe = calloc(1, user_data_recipe_size);

    user_data_recipe->key = MACH_VOUCHER_ATTR_KEY_USER_DATA;
    user_data_recipe->command = MACH_VOUCHER_ATTR_USER_DATA_STORE;
    user_data_recipe->content_size = content_size;
    *(uint64_t *)user_data_recipe->content = id;
    return user_data_recipe;
}

mach_port_t create_voucher(size_t content_size, mach_voucher_attr_recipe_t recipe) {
    mach_port_t new_voucher, host;
    kern_return_t kr;
    size_t user_data_recipe_size;
    
    host = mach_host_self();

    user_data_recipe_size = sizeof(mach_voucher_attr_recipe_data_t) + content_size;

    new_voucher = MACH_PORT_NULL;
    kr = host_create_mach_voucher(
            host,
            (mach_voucher_attr_raw_recipe_array_t) recipe,
            user_data_recipe_size,
            &new_voucher);        

    return new_voucher;
}

mach_port_t redeem_voucher(mach_port_t previous_voucher) {
    mach_port_t host, new_voucher;
    kern_return_t kr;
    mach_voucher_attr_recipe_t user_data_recipe;
    size_t user_data_recipe_size;
    
    host = mach_host_self();

    user_data_recipe_size = sizeof(mach_voucher_attr_recipe_data_t);
    user_data_recipe = calloc(1, user_data_recipe_size);

    user_data_recipe->key = MACH_VOUCHER_ATTR_KEY_USER_DATA;
    user_data_recipe->command = MACH_VOUCHER_ATTR_REDEEM;
    user_data_recipe->previous_voucher = previous_voucher;  

    new_voucher = MACH_PORT_NULL;
    kr = host_create_mach_voucher(
            host,
            (mach_voucher_attr_raw_recipe_array_t) user_data_recipe,
            user_data_recipe_size,
            &new_voucher);

    free(user_data_recipe);
    return new_voucher; 
}

mach_voucher_attr_recipe_t multiple_redeem_voucher_recipe(mach_port_t previous_voucher, int number_of_recipes) {
    mach_voucher_attr_recipe_data_t *user_data_recipe;
    int i;

    user_data_recipe = calloc(number_of_recipes, sizeof(mach_voucher_attr_recipe_data_t));

    for (i = 0; i < number_of_recipes; i++) {
        user_data_recipe[i].key = MACH_VOUCHER_ATTR_KEY_USER_DATA;
        user_data_recipe[i].command = MACH_VOUCHER_ATTR_REDEEM;
        user_data_recipe[i].content_size = 0;
        user_data_recipe[i].previous_voucher = previous_voucher;
    }

    return user_data_recipe;
}

mach_port_t multiple_redeem_voucher(mach_voucher_attr_recipe_t recipe, int number_of_recipes) {
    mach_port_t host, new_voucher;
    kern_return_t kr;
    int i;
    size_t user_data_recipe_size;

    host = mach_host_self();

    user_data_recipe_size = sizeof(mach_voucher_attr_recipe_data_t) * number_of_recipes;

    new_voucher = MACH_PORT_NULL;
    kr = host_create_mach_voucher(
            host,
            (mach_voucher_attr_raw_recipe_array_t) recipe,
            user_data_recipe_size,
            &new_voucher);

    return new_voucher;    
}

void release_voucher(mach_port_t voucher_port) {
   kern_return_t kr; 
   kr = mach_port_destroy(mach_task_self(), voucher_port);
}